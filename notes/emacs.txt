Notes:
   : Setup on RHEL5
       wget http://ftp.gnu.org/pub/gnu/emacs/emacs-23.4.tar.gz
       ./configure --prefix=/nas/home/boreilly/sw/emacs-install --with-gif=no
   : Patches:
      http://lists.gnu.org/archive/html/emacs-devel/2012-08/msg00441.html
      http://lists.gnu.org/archive/html/emacs-devel/2012-08/msg00628.html
   : Editting macros
      C-x( 	start-kbd-macro 	Starts recording keystrokes
      C-x) 	end-kbd-macro	Stop recording keystrokes
      C-xe 	call-last-kbd-macro 	
      C-g 	keyboard-quit 	quit defining
      C-uC-x( 		Executes current macro and opens it for appending new commands
              name-last-kbd-macro 	Gives the macro a name
              insert-kbd-macro	inserts the textual definition at the current point
      usually done into the .emacs file
              set-local-key key macroname 	binds the key name to the macro for this session
      C-uC-xq		Insert a pause into a macro definition
      ESC C-c 	Continue in the macro after a pause
   : C-z cycles between <N> and <E> evil states.
   : Buffer menu notes:
      : To see it:
         : C-x C-b 
         : buffer-menu
      : 1 selects one file in one window.
      : bs-show is a more barebones menu function.
   : Windows notes:
      : Gets rid of all other windows: C-x 1
      : Change to other window: C-x o
      : Split the same window side by side: C-x 3
   : Keymap notes:
      : An entry in a keymap can redirect to the key in a specified alternate keymap.
      : To determine the code for a key (C-c for example):
         (progn ?\C-c)
   : Ediff notes:
      : Multi-file patches:
         : Requires context or unified diffs (-c or -u).
            : Use diff -u
         : Doesn't appear to work on directory structures
            : Workaround: Copy files to a directory to structure is flat
         : Steps:
            : Open emacs on the diff file
            : M-x ediff-patch-file
            : Follow prompts
   : Etags
      : Call visit-tag-table function to load TAGS file.
   : Use M-; on a selection to comment it out.
   : (define-key evil-normal-state-map "o" 'next-buffer)
   : (define-key evil-normal-state-map "O" 'previous-buffer)
   : Define a function which can be called with M-x (and therefore evil mappings)
      (defun myCommand ()
        "One sentence summary of what this command do.

      More detailed documentation here."
        (interactive) ; Can have params to allow user inputted arguments
        (let (localVar1 localVar2 …)
          ; do something here …
          ; …
          ; last expression is returned
        )
      )
   : Help commands:
      : C-h a command-apropos
      : C-h b describe-bindings 
      : C-h c which command does this keystroke invoke (briefly in minibuffer)
      : C-h k which command does this keystroke invoke and what does it do?
      : C-h l what were my last 100 typed keys
      : C-h w what key-combo does this command have?
      : C-h f what does this function do
      : C-h v what's this variable and what is it's value
      : C-h m describe-mode describes major mode and lists minor modes
      : C-h i See Elisp manual among other things
      : C-u C-h i then path to .info file.
   : From http://sites.google.com/site/steveyegge2/effective-emacs
      : M-x describe-bindings
      : M-x describe-key
      : M-x apropos <regex>
      : M-x info
   : Customization notes:
      : These two do the same thing:
         ;; Set manually
         (setq evil-overriding-maps nil)
         ;; Set via the Emacs customization
         (custom-set-variables
          '(evil-overriding-maps nil)
          )
   : nxml-mode for XML editing.
   : F keys:
      (define-key python-mode-map (kbd "<f12>") 'python-switch-to-python)
   : Eval:
      M-:
   : Key chords:
      See http://permalink.gmane.org/gmane.emacs.vim-emulation/1170
   : Vim mapping plan:
      : Vim keys that aren't mapped to anything useful:
         t mapped
         , mapped Emacs execution of keyboard macro
         o mapped
         [
         ]
         \ mapped
         s use as prefix key
         f map to buffer menu
         ; mapped
         ' mapped
         c map as prefix key to various C- keys eg ch map to C-h
      : Vim shift- keys that aren't mapped to anything useful:
         O
         (
         )
         {
         }
         TODO
   : If Evil mode isn't enabled in a mode, revisit:
      http://lists.gnu.org/archive/html/bug-gnu-emacs/2012-01/msg00776.html
   : Tabs and spaces:
      http://cscs.umich.edu/~rlr/Misc/emacs_tabs.htm
   : Special characters:
      : Tab: hit tab key
      : Line feed: C-q C-j
   : Run emacs without reading .emacs:
      emacs --no-init-file
   : Editing lisp:
      : CL Wiki: http://www.cliki.net/Editing%20Lisp%20Code%20with%20Emacs
      : There are experimental ParEdit patches.
         : http://mumble.net/~campbell/tmp/paredit/
         : None look compelling given their experimental nature.
   : ClearCase
      : Key bindings:
         C-x v =        diff prev version
         C-x v o        checkout
         C-x v n        checkin
         C-x v u        uncheckout
         C-c C-c        finish comment
Retired issues with residual notes:
   : All things C-g does C-c should do.
      : Mapping to keyboard-escape-quit appears to cover most cases, except for quiting with unsaved mods.
      : Try keyboard-translate or key-translation-map
         : An example is described here: http://emacswiki.org/emacs-en/BackspaceKey
   : Using function advice to add prefix to message function.
      : Turns out to not work well in the minibuffer when error messages are written, eg:
         : Searching with evil-search, upon typing the first char that doesn't yield a match.
      : For posterity, the code:
         (defadvice message (before message-add-prefix-advice
                                    (format-string &rest args))
           "Add prefix string to message."
           (let ((format-string-pos 0) (args-pos 1))
             ; Error if I use ad-set-arg.  Maybe because of the documented
             ; "riskiness" of advising primitive functions.
             ;(ad-set-arg (ad-get-arg format-string-pos) (concat "%s" format-string))
             (setq format-string (concat "%s" format-string))
             (setq args (cons (format "%s " (get-time-str)) args))
             ))
         ; Declare args for efficiency of primitive function advising.
         (ad-define-subr-args 'message '(format-string &rest args))
         (ad-activate 'message)
   : Notes about inserting Unicode characters
      : Codes of interest (hex):
         : • is 2022
         : μ is 03bc
         : σ is 03c3
      : Can use function ucs-insert which has key binding C-x 8 RET
      : Can use tex mode:
         : Commands:
            M-x set-input-method
            tex
            \bullet
         : Note: doesn't set the input method back.
   : Notes about the isearch evil-search-module
      : Attempted to make lazy highlighting work
         : Code:
            (setq lazy-highlight-cleanup nil)
            (setq lazy-highlight-max-at-a-time nil)
            (setq lazy-highlight-initial-delay 0)
         : Problems:
            : Doesn't highlight outside of visible area.
      : Attempted to get highlight-regexp to work
         : Code:
            (setq search-highlight nil)
            (setq isearch-lazy-highlight nil)
            ; ...
            (defun my-hi-lock-process-phrase(phrase)
               "My hack of hi-lock-process-phrase function in hi-lock.el . "
               (setq mod-phrase
                      (replace-regexp-in-string
                       "\\<[a-z]" (lambda (m) (format "[%s%s]" (upcase m) m)) phrase))
            )
            (defun my-isearch-exit ()
               (when (boundp 'hi-lock-interactive-patterns)
                  (mapc (lambda (p)
                          (unhighlight-regexp (car p)))
                        hi-lock-interactive-patterns)
               )
               ( setq search-term (car (if isearch-regexp regexp-search-ring search-ring)) )
               (if (equal search-term (downcase search-term))
                  ; Case insensitive
                  (progn
                     ; This is close to interactive highlight-phrase but without the white space rule.
                     (highlight-regexp (my-hi-lock-process-phrase search-term) 'hi-pink)
                  )
                  ; Case sensitive
                  (progn
                     (highlight-regexp search-term 'hi-pink)
                  )
               )
               (lazy-highlight-cleanup t)
            )
            (add-hook 'isearch-mode-end-hook 'my-isearch-exit)
            ; ...
            (defadvice isearch-exit (after my-isearch-exit activate)
               "Go to beginning of match, after isearch, highlight the search term "
               (when isearch-forward (goto-char isearch-other-end))
              (highlight-regexp (car (if isearch-regexp
                                         regexp-search-ring
                                       search-ring)) (find-face 'hi-pink))
            )
         : Problems:
            : highlight-regexp doesn't case-fold the same way.
      : To escape:
         (define-key isearch-mode-map (kbd "C-c") 
            (lambda ()
               (interactive)
               (dotimes (num 2) (isearch-abort))
            )
         )
   : Auto Complete
      ;;; Initialize Auto Complete
      (defvar my-ac-build-path "~/.emacs.d/auto-complete-1.3.1/build" "Path to built ac")
      (defun setup-auto-complete ()
        "Set up Auto Complete"
         ;; Initialize 
         (log-msg "Initializing Auto Complete.")
         (add-to-list 'load-path my-ac-build-path)
         (require 'auto-complete-config)
         (add-to-list 'ac-dictionary-directories (format "%s/ac-dict" my-ac-build-path))
         (ac-config-default)

         ;; Configure
         ;;
         ;; RET can cause auto completion when literal RET is what I want.
         ;; Auto Complete is perfectly usable via TAB alone, so disable RET key binding.
         (define-key ac-complete-mode-map (kbd "RET") nil))
      ;; I'm not finding Auto Complete useful at the moment.
      ;; (init-auto-complete)
   : Java Auto Complete
      : Popup causes several seconds of delay.  What's the cause?
         : Try advice in dev's email, generate own smaller set of Java tags.
      : Why is there no popup for ajc-import-class-under-point?
          : auto-complete places text under point.  See mailing list.
   : Keymapping
      : Edebug keymapping
         : How to have Edebug go to motion state?
            ;;(evil-set-initial-state 'debugger-mode 'motion) ; Doesn't work for Edebug
            ;; (delete 'debugger-mode evil-emacs-state-modes) ; How to delete from state-modes
         : Setting evil-overriding-maps and evil-intercept-maps to nil allowed Evil keybindings
      : How to change minor mode keymap priorities:
         : http://stackoverflow.com/questions/9648218/conflicting-keyboard-shortcuts-in-two-emacs-minor-modes
         : http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs/5340797#5340797
      : Mapping key sequence to global prefix keymap.
         : Don't work:
            ;; (define-key evil-motion-state-map "cc" (lambda () (interactive) mode-specific-map))
            ;;        ; Reason: "cc" does nothing, probably returns variable but doesn't know to use it as a keymap.
            ;; (define-key evil-motion-state-map "cc" mode-specific-map)
            ;;        ; Reason: Looks in function cell of mode-specific-map, but it's a variable.
            ;; (define-key evil-motion-state-map "cc" 'mode-specific-map)
            ;;        ; Reason: Looks in function cell of mode-specific-map, but it's a variable.
         : Works partially:
            ;; (define-key evil-motion-state-map "cc" mode-specific-map)
            ;; (define-key evil-motion-state-map "ch" help-map)
            ;; (define-key evil-motion-state-map "cx" ctl-x-map)
      : Use Key Translations which are active based on Evil state.
         : Patch: http://lists.gnu.org/archive/html/emacs-devel/2012-08/msg00449.html
         : Another patch: http://lists.gnu.org/archive/html/emacs-devel/2012-08/msg00628.html
         : Neither patch is in 24.2, but is on the Emacs trunk.
      : Xah Lee reports bug with universal argument and key-translation-map
         https://groups.google.com/forum/?fromgroups#!topic/comp.emacs/p7PLJgWzNkY
   : File reloading:
      : Figure out how to make reloading a file from disk less annoying.
         : It would be good to have similar abstraction as Vim:
            : When leaving file that is unsaved, prompt the user.  Allow for an override.
            : When visiting a file, reload it from disk.
      : A solution to this should also solve Clearcase checkout annoyances.  clearcase.el slows down init.
      : auto-revert
         : Doesn't revert file permissions, even though revert-buffer does.
            : Submitted bug report to GNU, ID 11549, merged with ID 11412.
               : The auto-revert-handler function locally binds buffer-read-only so as when revert-buffer updates it, it's lost at the end of the local binding.
         : Has high latency
            : Might be configurable
         : Flash screen when auto revert occurs.
      : revert-buffer invocation
         : Perhaps when start viewing buffer
            : Investigate using window-scroll-functions for this.
               : See http://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Hooks.html
               : Tried copying Evil's example for using window-scroll-functions, but can't get my-window-scroll invoked.
                  (defun my-window-scroll
                    (log-msg "Inside my-window-scroll"))
                  (add-hook 'window-scroll-functions 'my-window-scroll nil t)
         : Consider whether I'm ok with losing undo history.  Maybe make it conditional for the need to revert.

